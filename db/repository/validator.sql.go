// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: validator.sql

package querier

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createDailyAggregate = `-- name: CreateDailyAggregate :one
INSERT INTO daily_aggregates (validator_address, delegator_address, date, total_amount)
VALUES ($1, $2, $3, $4) RETURNING id
`

type CreateDailyAggregateParams struct {
	ValidatorAddress string    `json:"validator_address"`
	DelegatorAddress string    `json:"delegator_address"`
	Date             time.Time `json:"date"`
	TotalAmount      int64     `json:"total_amount"`
}

func (q *Queries) CreateDailyAggregate(ctx context.Context, arg CreateDailyAggregateParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createDailyAggregate,
		arg.ValidatorAddress,
		arg.DelegatorAddress,
		arg.Date,
		arg.TotalAmount,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createDelegationSnapshot = `-- name: CreateDelegationSnapshot :one
INSERT INTO delegation_snapshots (
    validator_address,
    delegator_address,
    amount_uatom,
    change_uatom,
    timestamp
)
VALUES ($1, $2, $3, $4, $5)
RETURNING id
`

type CreateDelegationSnapshotParams struct {
	ValidatorAddress string    `json:"validator_address"`
	DelegatorAddress string    `json:"delegator_address"`
	AmountUatom      int64     `json:"amount_uatom"`
	ChangeUatom      int64     `json:"change_uatom"`
	Timestamp        time.Time `json:"timestamp"`
}

func (q *Queries) CreateDelegationSnapshot(ctx context.Context, arg CreateDelegationSnapshotParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createDelegationSnapshot,
		arg.ValidatorAddress,
		arg.DelegatorAddress,
		arg.AmountUatom,
		arg.ChangeUatom,
		arg.Timestamp,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getCountDailyAggregateByValidator = `-- name: GetCountDailyAggregateByValidator :one
 SELECT COUNT(*)
    FROM daily_aggregates
    WHERE validator_address = $1
`

func (q *Queries) GetCountDailyAggregateByValidator(ctx context.Context, validatorAddress string) (int64, error) {
	row := q.db.QueryRow(ctx, getCountDailyAggregateByValidator, validatorAddress)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountDelegationSnapshotByValidator = `-- name: GetCountDelegationSnapshotByValidator :one
 SELECT COUNT(*)
    FROM delegation_snapshots
    WHERE validator_address = $1
`

func (q *Queries) GetCountDelegationSnapshotByValidator(ctx context.Context, validatorAddress string) (int64, error) {
	row := q.db.QueryRow(ctx, getCountDelegationSnapshotByValidator, validatorAddress)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountDelegatorHistoryByValidator = `-- name: GetCountDelegatorHistoryByValidator :one
SELECT COUNT(*)
    FROM delegation_snapshots
    WHERE validator_address = $1 AND delegator_address = $2
`

type GetCountDelegatorHistoryByValidatorParams struct {
	ValidatorAddress string `json:"validator_address"`
	DelegatorAddress string `json:"delegator_address"`
}

func (q *Queries) GetCountDelegatorHistoryByValidator(ctx context.Context, arg GetCountDelegatorHistoryByValidatorParams) (int64, error) {
	row := q.db.QueryRow(ctx, getCountDelegatorHistoryByValidator, arg.ValidatorAddress, arg.DelegatorAddress)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getDailyAggregateByValidator = `-- name: GetDailyAggregateByValidator :many
 SELECT delegator_address, date, total_amount
    FROM daily_aggregates
    WHERE validator_address = $1
    ORDER BY date ASC
    LIMIT $2
    OFFSET $3
`

type GetDailyAggregateByValidatorParams struct {
	ValidatorAddress string `json:"validator_address"`
	Limit            int32  `json:"limit"`
	Offset           int32  `json:"offset"`
}

type GetDailyAggregateByValidatorRow struct {
	DelegatorAddress string    `json:"delegator_address"`
	Date             time.Time `json:"date"`
	TotalAmount      int64     `json:"total_amount"`
}

func (q *Queries) GetDailyAggregateByValidator(ctx context.Context, arg GetDailyAggregateByValidatorParams) ([]GetDailyAggregateByValidatorRow, error) {
	rows, err := q.db.Query(ctx, getDailyAggregateByValidator, arg.ValidatorAddress, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDailyAggregateByValidatorRow{}
	for rows.Next() {
		var i GetDailyAggregateByValidatorRow
		if err := rows.Scan(&i.DelegatorAddress, &i.Date, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDelegationSnapshotByValidator = `-- name: GetDelegationSnapshotByValidator :many
 SELECT delegator_address, amount_uatom, timestamp, change_uatom
    FROM delegation_snapshots
    WHERE validator_address = $1
    ORDER BY timestamp ASC
    LIMIT $2
    OFFSET $3
`

type GetDelegationSnapshotByValidatorParams struct {
	ValidatorAddress string `json:"validator_address"`
	Limit            int32  `json:"limit"`
	Offset           int32  `json:"offset"`
}

type GetDelegationSnapshotByValidatorRow struct {
	DelegatorAddress string    `json:"delegator_address"`
	AmountUatom      int64     `json:"amount_uatom"`
	Timestamp        time.Time `json:"timestamp"`
	ChangeUatom      int64     `json:"change_uatom"`
}

func (q *Queries) GetDelegationSnapshotByValidator(ctx context.Context, arg GetDelegationSnapshotByValidatorParams) ([]GetDelegationSnapshotByValidatorRow, error) {
	rows, err := q.db.Query(ctx, getDelegationSnapshotByValidator, arg.ValidatorAddress, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDelegationSnapshotByValidatorRow{}
	for rows.Next() {
		var i GetDelegationSnapshotByValidatorRow
		if err := rows.Scan(
			&i.DelegatorAddress,
			&i.AmountUatom,
			&i.Timestamp,
			&i.ChangeUatom,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDelegationSnapshotByValidatorAndDelegator = `-- name: GetDelegationSnapshotByValidatorAndDelegator :one
 SELECT id, validator_address, 
        delegator_address, amount_uatom, 
        change_uatom, timestamp 
    FROM delegation_snapshots
    WHERE validator_address = $1 AND delegator_address = $2
    ORDER BY timestamp DESC LIMIT 1
`

type GetDelegationSnapshotByValidatorAndDelegatorParams struct {
	ValidatorAddress string `json:"validator_address"`
	DelegatorAddress string `json:"delegator_address"`
}

type GetDelegationSnapshotByValidatorAndDelegatorRow struct {
	ID               uuid.UUID `json:"id"`
	ValidatorAddress string    `json:"validator_address"`
	DelegatorAddress string    `json:"delegator_address"`
	AmountUatom      int64     `json:"amount_uatom"`
	ChangeUatom      int64     `json:"change_uatom"`
	Timestamp        time.Time `json:"timestamp"`
}

func (q *Queries) GetDelegationSnapshotByValidatorAndDelegator(ctx context.Context, arg GetDelegationSnapshotByValidatorAndDelegatorParams) (GetDelegationSnapshotByValidatorAndDelegatorRow, error) {
	row := q.db.QueryRow(ctx, getDelegationSnapshotByValidatorAndDelegator, arg.ValidatorAddress, arg.DelegatorAddress)
	var i GetDelegationSnapshotByValidatorAndDelegatorRow
	err := row.Scan(
		&i.ID,
		&i.ValidatorAddress,
		&i.DelegatorAddress,
		&i.AmountUatom,
		&i.ChangeUatom,
		&i.Timestamp,
	)
	return i, err
}

const getDelegatorHistoryByValidator = `-- name: GetDelegatorHistoryByValidator :many
SELECT timestamp, amount_uatom, change_uatom
    FROM delegation_snapshots
    WHERE validator_address = $1 AND delegator_address = $2
    ORDER BY 
    CASE WHEN $5::text = '-date' THEN "timestamp" END DESC,
    CASE WHEN $5::text = 'date' THEN "timestamp" END ASC
    LIMIT $3
    OFFSET $4
`

type GetDelegatorHistoryByValidatorParams struct {
	ValidatorAddress string `json:"validator_address"`
	DelegatorAddress string `json:"delegator_address"`
	Limit            int32  `json:"limit"`
	Offset           int32  `json:"offset"`
	SortBy           string `json:"sort_by"`
}

type GetDelegatorHistoryByValidatorRow struct {
	Timestamp   time.Time `json:"timestamp"`
	AmountUatom int64     `json:"amount_uatom"`
	ChangeUatom int64     `json:"change_uatom"`
}

func (q *Queries) GetDelegatorHistoryByValidator(ctx context.Context, arg GetDelegatorHistoryByValidatorParams) ([]GetDelegatorHistoryByValidatorRow, error) {
	rows, err := q.db.Query(ctx, getDelegatorHistoryByValidator,
		arg.ValidatorAddress,
		arg.DelegatorAddress,
		arg.Limit,
		arg.Offset,
		arg.SortBy,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDelegatorHistoryByValidatorRow{}
	for rows.Next() {
		var i GetDelegatorHistoryByValidatorRow
		if err := rows.Scan(&i.Timestamp, &i.AmountUatom, &i.ChangeUatom); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestDelegationSnapshot = `-- name: GetLatestDelegationSnapshot :many
SELECT DISTINCT ON (delegator_address, validator_address)
           validator_address, delegator_address, amount_uatom
    FROM delegation_snapshots
    ORDER BY delegator_address, validator_address, timestamp DESC
`

type GetLatestDelegationSnapshotRow struct {
	ValidatorAddress string `json:"validator_address"`
	DelegatorAddress string `json:"delegator_address"`
	AmountUatom      int64  `json:"amount_uatom"`
}

func (q *Queries) GetLatestDelegationSnapshot(ctx context.Context) ([]GetLatestDelegationSnapshotRow, error) {
	rows, err := q.db.Query(ctx, getLatestDelegationSnapshot)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLatestDelegationSnapshotRow{}
	for rows.Next() {
		var i GetLatestDelegationSnapshotRow
		if err := rows.Scan(&i.ValidatorAddress, &i.DelegatorAddress, &i.AmountUatom); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
